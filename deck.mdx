import { CodeSurfer } from "mdx-deck-code-surfer"
import { Image, Head } from 'mdx-deck'
import { default as base } from 'mdx-deck/themes'
import Mermaid from './components/mermaid'
import prismStyle from 'react-syntax-highlighter/styles/prism/ghcolors'
import erlang from 'react-syntax-highlighter/languages/prism/erlang'

<Head>
  <title>erlang ìŠ¤í„°ë”” 5ë²ˆì§¸ ë°œí‘œ</title>

  <meta property="og:type" content="website"/>
  <meta property="og:url" content="https://lyse-5.chitacan.io"/>
  <meta property="og:image" content="https://learnyousomeerlang.com/static/img/splash-book.png"/>
  <meta property="og:image:type" content="image/png"/>
  <meta property="og:title" content="erlang"/>
  <meta property="og:description" content="erlang ìŠ¤í„°ë”” 5ë²ˆì§¸ ë°œí‘œ"/>

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:domain" content="lyse-5.chitacan.io" />
  <meta name="twitter:title" content="erlang" />
  <meta name="twitter:description" content="erlang ìŠ¤í„°ë”” 3ë²ˆì§¸ ë°œí‘œ" />
  <meta name="twitter:url" content="https://lyse-5.chitacan.io" />
  <meta name="twitter:image" content="https://learnyousomeerlang.com/static/img/splash-book.png" />
</Head>

export const theme = {
  ...base,
  css: {
    ...base.css,
    '*': {
      wordBreak: 'keep-all'
    },
    'li > ul, li > ol': {
      fontSize: '1em'
    },
    'li > p': {
      fontSize: '1em',
      margin: 0,
    },
    li: {
      margin: '8px 0'
    },
    sup: {
      display: 'block',
      fontSize: '0.7em',
      textAlign: 'left',
      color: '#bbb'
    },
    kbd: {
      backgroundColor: '#fafbfc',
      border: '1px solid #c6cbd1',
      borderBottomColor: '#959da5',
      borderRadius: '5px',
      boxShadow: 'inset 0 -1px 0 #959da5',
      color: '#444d56',
      display: 'inline-block',
      padding: '3px 5px',
      verticalAlign: 'middle'
    }
  },
  prism: {
    style: {...prismStyle},
    languages: {
      erlang
    }
  }
}

# erlang

<a href="https://chitacan.io" target="_blank">@chitacan</a>

---

## chapters

* [chapter 25. Bears, ETS, Beets](https://learnyousomeerlang.com/ets)
* [chapter 26. Distribunomicon](https://learnyousomeerlang.com/distribunomicon)
* [chapter 27. Distributed OTP Applications](https://learnyousomeerlang.com/distributed-otp-applications)
* [chapter 28. Common Test for Uncommon Tests](https://learnyousomeerlang.com/common-test-for-uncommon-tests)

---

## chapters

* (ì¬ë¯¸ì—†ì„ ê²ƒ ê°™ì€)`ETS`, `common test` ë¥¼ ë‹¤ë£¨ëŠ” 25, 28 ì¥ì€ ëŒ€ì¶© ë³´ê³ ,
* ì¬ë¯¸ìˆì„ ê²ƒ ê°™ì€ 26, 27 ì¥ì„ ì§‘ì¤‘ì ìœ¼ë¡œ íŒ ìŠµë‹ˆë‹¤.

---

## chapter 25. Bears, ETS, Beets

---

## ETS

* `Erlang Term Storage`
* efficient **in-memory** database included with the Erlang VM
* store large amounts of data with constant access time
* supports **ONLY tuples**
* no transactions
* DETS (disk-based ETS)

---

## ETS ì‚¬ìš©í•˜ê¸° (1)

```erlang
$ erl
1> ets:new(ingredients, [set, named_table]).
ingredients
2> ets:insert(ingredients, {bacon, great}).
true
3> ets:lookup(ingredients, bacon).
[{bacon,great}]
4> ets:insert(ingredients, {bacon, awesome}, {cabbage, alright}).
true
3> ets:lookup(ingredients, bacon).
[{bacon,awesome}]
4> ets:delete(ingredients, cabbage).
true
5> ets:lookup(ingredients, cabbage).
[]
```

---

## ETS ì‚¬ìš©í•˜ê¸° (2)

```erlang
$ erl
1> ets:new(table, [ordered_set, named_table]).
table
2> ets:insert(table, [{a, 10}, {z, 70}, {c, 20}]).
true
3> ets:first(table).
a
4> ets:next(table, a).
c
4> ets:last(table).
z
```

---

## ETS match & select

```erlang
$ erl
1> ets:new(table, [bag, named_table]).
table
2> ets:insert(table, [{items,1,1},
                      {items,6,7},
                      {items,3,4},
                      {items,1,2}]).
true
3> ets:match(table, {items, '$1', '$1'}).
[[1]]
4> ets:match_object(table, {items, '$1', '$1'}).
[{items,1,1}]
5> ets:select(table, [{{items,'$1','_'},[{'>','$1',5}],['$_']}]).
[{items,6,7}]
6> ets:select(table, ets:fun2ms(fun(N = {items,X,_}) when X > 5 -> N end)).
[{items,6,7}]
```

---

## chapter 26. Distribunomicon

---

## Erlang ì˜ ë§¤ë ¥?

ë“œë””ì–´ 3ë²ˆì§¸ ë§¤ë ¥ì„ í•™ìŠµí•  ì°¨ë¡€!!

* functional language
* semantics for concurrency
* **supports distribution**

---

# ğŸ˜±

> "Distributed programming is like being left alone in the dark, with monsters everywhere."

---

## Bad news

Distributed Erlang is **still** leaving you alone in the dark.

---

## Good news

Erlang gives you some tools. (not solutions)

* many nodes (VMs) can connect & communicate with each other
* extending multiple process concept to many nodes

---

## Tools

Erlang gives you

* `net_kernel`
* `global`
* `rpc`
* `remote shells`
* `dist_ac`
* ...

---

## Fallacies of Distributed Computing

* Erlang ì´ ì£¼ëŠ” íˆ´ë“¤ì„ ì´ì• í•˜ê¸° ìœ„í•´ì„œëŠ” ë¶„ì‚°í™˜ê²½ì—ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œë“¤ì— ëŒ€í•´ì„œ ì•Œê³  ìˆì„ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.
* ë˜‘ë˜‘í•œ ë¶„ë“¤ì´ ë¶„ì‚°í™˜ê²½ì—ì„œ ì˜ëª»ë  ìˆ˜ ìˆëŠ” ê°€ì •ë“¤ì„ 8ê°€ì§€ë¡œ ì •ë¦¬í•´ ë†“ì•˜ìŠµë‹ˆë‹¤.
* http://www.rgoarchitects.com/Files/fallacies.pdf

---

1. The network is reliable
2. There is no latency
3. Bandwidth is infinite
4. The network is secure
5. Topolgy doesn't change
6. There is only one admin
7. Transport cost is zero
8. The network is homogeneous

---

## CAP Theorem

**C**onsistency, **A**vailability, **P**arition tolerance ë¥¼ ëª¨ë‘ ë§Œì¡±í•˜ëŠ”ê±´ ë¶ˆê°€ëŠ¥í•˜ë‹¤...

---

## connecting nodes

```erlang
$ erl -sname hi
(hi@cmbp)1>
```

```erlang
$ erl -sname ho
(ho@cmbp)1> net_kernel:connect_node(hi@cmbp).
true
(ho@cmbp)2> net_kernel:i(hi@cmbp).
Node     = hi@cmbp
State    = up
Type     = normal
In       = 17
Out      = 16
Address  = 127.0.0.1:60313
ok
(ho@cmbp)2> nodes()
[hi@cmbp]
```

<sup>ì±…ì— ë‚˜ì˜¨ <code>net_kernel:connect</code> ëŠ” ì—†ì–´ì§„ë“¯?</sup>

---

## epmd

Erlang Port Mapper Daemon

* [node (VM) ì´ ì‹¤í–‰ë ë•Œ ê°™ì´ ì‹¤í–‰](https://github.com/erlang/otp/blob/d6285b0a347b9489ce939511ee9a979acd868f71/lib/erl_interface/src/prog/erl_start.c#L181) ë˜ëŠ” í”„ë¡œì„¸ìŠ¤
  * `-start_epmd false` ì˜µì…˜ìœ¼ë¡œ epmd ì‹¤í–‰ì„ ì œí•œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
* í•˜ë‚˜ì˜ ì‹œìŠ¤í…œì— í•˜ë‚˜ë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤.
* ê¸°ë³¸ì ìœ¼ë¡œ `4369` í¬íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
* ì´ë¦„ì´ ì£¼ì–´ì§„ ëª¨ë“  node ëŠ” epmd ì— ìì‹ ì˜ ì´ë¦„ì„ ë“±ë¡í•©ë‹ˆë‹¤.
  * node ì— ëŒ€í•œ port ì •ë³´ëŠ” epmd ë¥¼ í†µí•´ ì¡°íšŒí•©ë‹ˆë‹¤.
  * ìƒˆë¡œìš´ node ëŠ” cluster ì— ì†í•œ node ì¤‘ í•˜ë‚˜ë¼ë„ ì—°ê²°ë˜ë©´ [ë‚˜ë¨¸ì§€ node ì˜ ì´ë¦„ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.](http://erlang.org/doc/apps/erts/erl_dist_protocol.html#protocol-between-connected-nodes)

---

## sending messages

```erlang
$ erl -sname hi
(hi@cmbp)1> register(shell, self()).
true
```

```erlang
$ erl -sname ho
(ho@cmbp)1> register(shell, self()).
true
(ho@cmbp)2> net_kernel:connect_node(hi@cmbp).
true
(ho@cmbp)3> {shell, hi@cmbp} ! {hello, self()}.
```

```erlang
(hi@cmbp)2> receive {hello, Other} -> Other ! "ho there!" end.
"ho there!"
```

```erlang
(ho@cmbp)4> flush().
Shell got "ho there!"
ok
```

---

## sending messages

<Mermaid id="send_msg" content={`
sequenceDiagram
  participant ho@cmbp
  participant hi@cmbp
  hi@cmbp-->>hi@cmbp: register(shell, self())
  ho@cmbp-->>ho@cmbp: register(shell, self())
  ho@cmbp->>hi@cmbp: net_kernel:connect_node(hi@cmbp)
  ho@cmbp->>+hi@cmbp: {hello, self()}
  hi@cmbp-->>-ho@cmbp: "ho there!"
  ho@cmbp-->>ho@cmbp: flush()
  Note over ho@cmbp: "ho there!"
`} />

---

## spawn

```erlang
$ erl -sname hi
(hi@cmbp)1>
```

```erlang
$ erl -sname ho
(ho@cmbp)1> spawn(hi@cmbp, fun() ->
(ho@cmbp)1>   io:format("I'm on ~p~n", [node()])
(ho@cmbp)1> end).
I'm on hi@cmbp
<8490.145.0>
````

---

## remote shells

Erlang shell ì—ì„œ <kbd>ctrl-G</kbd> ì„ í†µí•´ ë‹¤ë¥¸ node ì— shell ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* shell ì€ ë³„ë„ì˜ í”„ë¡œì„¸ìŠ¤ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.
* auto-completion ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
* `q()` ë˜ëŠ” `init:stop()` ì„ í˜¸ì¶œí•˜ë©´ node ê°€ ì¢…ë£Œë˜ë‹ˆ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

```
(hi@cmbp)1>
User switch command
 --> h
  c [nn]            - connect to job
  i [nn]            - interrupt job
  k [nn]            - kill job
  j                 - list all jobs
  s [shell]         - start local shell
  r [node [shell]]  - start remote shell
  q                 - quit erlang
  ? | h             - this message
 --> j
   1   {shell,start,[init]}
   2 * {ho@cmbp,shell,start,[]}
 --> c
(ho@cmbp)1>
```

---

## `rpc` module

remote procedure call

ì›ê²© node ì˜ í•¨ìˆ˜ë¥¼ `MFA` ìŠ¤íƒ€ì¼ë¡œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```erlang
$ erl -sname hi
hi@cmbp1>
```
```erlang
$ erl -sname hu
hu@cmbp1>
```
```erlang
$ erl -sname ho
ho@cmbp1> rpc:call(hi@cmbp, lists, sort, [[a,e,f,t,h,s,a]]).
[a,a,e,f,h,s,t]
ho@cmbp2> Key = rpc:async_call(hi@cmbp, erlang, node, []).
<0.96.0>
ho@cmbp3> rpc:yield(Key).
hi@cmbp
ho@cmbp4> rpc:multicall([hi@cmbp, hu@cmbp], erlang, is_alive, []).
{[true,true],[]}
```
<sup><code>net_kernel:connect_node</code> ë¥¼ ë¯¸ë¦¬ í˜¸ì¶œí•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤.</sup>

---

## `rpc` ğŸ§™â€â™€ï¸

`code` ëª¨ë“ˆì„ ì‚¬ìš©í•˜ë©´ ì›ê²© node ì— ëª¨ë“ˆì„ ì „ì†¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```erlang
-module(my_module).
-export([say/1]).
say(Str) -> io:format(Str++" world~n").
```

```erlang
$ erl -sname hi
hi@cmbp1> c(my_module).
hi@cmbp2> {M, B, F} = code:get_object_code(my_module).
{my_module,<<70,79,82,49,...>>, "/root/my_module.beam"}
hi@cmbp3> rpc:call(ho@cmbp, code, load_binary, [M, F, B]).
{module,my_module}
hi@cmbp4> rpc:call(ho@cmbp, my_module, say, ["hello"]).
hello world
ok
```

```erlang
ho@cmbp1> my_module:say("ho").
hello ho
ok
```

---

## visualixir (1)

https://github.com/koudelka/visualixir


<img width="85%" src="https://raw.githubusercontent.com/koudelka/visualixir/master/doc/demo.gif"/>

---

## visualixir (2)

<Mermaid id="visualixir" content={`
graph LR
  visualixir_node -- "rpc.call(node, :code, :load_binary, [...])" --> node1
  visualixir_node -- "Node.spawn_link(node, :gen_server, :start, ...)" --> node1
  visualixir_node -- request trace --> node1
  node1-- trace messages --> visualixir_node
  visualixir_node -.-> node2
  visualixir_node -.-> node3
`} />

---

<div style={{fontSize: '19px'}}>
  <CodeSurfer
    title="visualixir (3)"
    code={require("!raw-loader!./snippets/tracer.ex")}
    steps={[
      {lines: [217,218,219,220], notes: "ì›ê²© node ë¡œ ëª¨ë“ˆ ìì‹ ì„ ì „ì†¡í•©ë‹ˆë‹¤."},
      {lines: [6,7,8,9,10,11,12,13], notes: "ì›ê²© node ì— ì „ì†¡ëœ ëª¨ë“ˆì„(gen_server) ì‹¤í–‰í•©ë‹ˆë‹¤."},
      {lines: [33,34,35,36,37], notes: "gen_server ê°€ ì‹¤í–‰ë˜ë©´, process ì™€ message ë¥¼ ì¶”ì í•©ë‹ˆë‹¤."},
    ]}
  />
</div>

---

## ì½ì€ ì†Œê°?

* í™•ì‹¤íˆ Erlang ì€ ì—¬ëŸ¬ê°€ì§€ ë„êµ¬(`node`, `rpc` ... )ë¥¼ ì œê³µí•˜ì§€ë§Œ, í•´ê²°ì±…ì„ ì •í™•í•˜ê²Œ ì£¼ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤ ã… 
* Erlang ì´ ì œê³µí•˜ëŠ” ë„êµ¬ë“¤ì„ í™œìš©í•´ ë¶„ì‚°í™˜ê²½ì—ì„œ êµ¬í˜„í•˜ê³ ì í•˜ëŠ” ì•±ì˜ ì»¨ì…‰ (`CAP Theorem`) ê³¼ ê·¸ ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œ(`Fallacies of Distributed Computing`)ì— ëŒ€ì‘í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.

---

# chapter 27. Distributed OTP Applications

---

## failover & takeover

failover

<Mermaid id="failover-1" content={`
graph TD
  node_a --> app
  node_b
  node_c
`} />

---

## failover & takeover

failover

<Mermaid id="failover-2" content={`
graph TD
  dead(node_a)
  node_b --> app
  node_c
  style dead opacity:0.3
`} />

---

## failover & takeover

failover

<Mermaid id="failover-3" content={`
graph TD
  dead1(node_a)
  dead2(node_b)
  node_c --> app
  style dead1 opacity:0.3
  style dead2 opacity:0.3
`} />

---

## failover & takeover

takeover

<Mermaid id="takeover" content={`
graph TD
  node_a --> app
  dead(node_b)
  node_c
  style dead opacity:0.3
`} />

---

## failover & takeover

`dist_ac` (distributed application) í”„ë¡œì„¸ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ failover & takeover ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<Mermaid id="takeover" content={`
graph TD
  a["application<br/>controller"] --> b["application<br/>master 1"]
  a --> c["application<br/>master 2"]
  a --> d["application<br/>master 3"]
  e["dist_ac"] --> f["application<br/>master 4"]
`} />

---

## failover & takeover

`dist_ac` ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” config íŒŒì¼ì— `distributed` ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.

```erlang
[{kernel,
  [{distributed, [{m8ball,
                   5000,
                  [a@cmbp, {b@cmbp, c@cmbp}]}]},
   {sync_nodes_mandatory, [b@cmbp, c@cmbp]},
   {sync_nodes_timeout, 30000}
  ]
 }
].
```

http://erlang.org/doc/design_principles/distributed_applications.html

---

## `m8ball`

`env` ì— ì„¤ì •ëœ ê°’ì„ ëœë¤í•˜ê²Œ ì¶œë ¥í•˜ëŠ” ì•„ì£¼ ê°„ë‹¨í•œ ì•±.

```erlang
{application, m9ball,
 [{vsn, "1.0.0"},
  {description, "Answer vital questions"},
  {modules, [m8ball, m8ball_sup, m8ball_server]},
  {applications, [stdlib, kernel, crypto]},
  {registered, [m8ball, m8ball_sup, m8ball_server]},
  {mod, {m8ball, []}},
  {env, [
    {answers, {<<"Yes">>, <<"No">>, <<"Doubtful">>,
               <<"I don't like your tone">>, <<"Of course">>,
               <<"Of course not">>, <<"*backs away slowly and runs away*">>}}
  ]}
 ]}.
```

```erlang
$ erl -make
$ erl -pa ebin
1> m8ball:ask("hi").
<<"Doubtful">>
```

---

## `m8ball`

<Mermaid id="m8ball" content={`
graph LR
  subgraph node_c
  c["dist_ac"] 
  end
  subgraph node_b
  b["dist_ac"] 
  end
  subgraph node_a
  a["dist_ac"] --> a_1["application<br/>master"]
  a_1 --> a_2["m8ball"]
  a_2 --> a_3["m8ball_sup"]
  a_3 --> a_4["m8ball_server"]
  end
`} />

---

## `m8ball`

`distributed` ì„¤ì •ë•ë¶„ì— 3ê°œì˜ ë…¸ë“œì—ì„œ ëª¨ë‘ ì ‘ê·¼ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```erlang
$ erl -sname a -config config/a -pa ebin
(a@cmbp)1>
```
```erlang
$ erl -sname b -config config/b -pa ebin
(b@cmbp)1>
```
```erlang
$ erl -sname c -config config/c -pa ebin
(c@cmbp)1> m8ball:ask("hi").
<<"Of course not">>
```

---

<CodeSurfer
  title="m8ball_server.erl"
  code={require("!raw-loader!./snippets/m8ball_server.erl")}
  steps={[
    {lines: [10,11,12,13,14,15,16,17], notes: () => (<p><code>pid</code> ëŒ€ì‹ ì— <code>&#123;global, NAME&#125;</code> ì„ ì‚¬ìš©í•´, ë‹¤ë¥¸ node ì—ì„œë„ <code>m8ball:ask</code>ë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>)}
  ]}
/>

---

<CodeSurfer
  title="m8ball.erl"
  code={require("!raw-loader!./snippets/m8ball.erl")}
  steps={[
    {lines: [14,15], notes: "takeover ë•Œ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” callback ì„ ì¶”ê°€í•©ë‹ˆë‹¤."}
  ]}
/>

---

## `m8ball`

* ì„¤ì •ì— ëª…ì‹œëœ 3ê°œì˜ node ê°€(`a`, `b`, `c`) ëª¨ë‘ ì‹¤í–‰ë˜ì–´ì•¼ì§€ë§Œ ì•±ì´ ì‹œì‘ë©ë‹ˆë‹¤.
  * `m8ball` ì•±ì€ í•˜ë‚˜ì˜ node ì—ì„œë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤.
* ì•±ì´ ì‹¤í–‰ì¤‘ì¸ node ê°€ ì¢…ë£Œë˜ë©´, ë‹¤ìŒ node ë¡œ failover ë©ë‹ˆë‹¤.
* node ê°€ ë‹¤ì‹œ ì‹¤í–‰ë˜ë©´, ê¸°ì¡´ node ë¡œ takeover ë©ë‹ˆë‹¤.
* ì™„ë²½í•œê°€? ğŸ¤” ëª‡ë²ˆ ì‹¤í–‰í•˜ë‹¤ë³´ë©´ takeover ê°€ ë˜ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ìˆì—ˆìŠµë‹ˆë‹¤...

---

## ì½ì€ ì†Œê°?

* ì„¤ì •ë§Œìœ¼ë¡œ distributed application ì„ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ê²ƒì€ ì¢‹ì•˜ì§€ë§Œ,
  * ì„¤ì •ìœ¼ë¡œ ì¸í•´ ë³€í•˜ëŠ” ì•±ì˜ ë™ì‘ë“¤ì„ ì¢€ ë” í™•ì¸í•˜ê³  ì‹¶ì–´ì¡ŒìŠµë‹ˆë‹¤.
  * `elixir` ì—ì„œëŠ” ì–´ë–»ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ì§€ ê¶ê¸ˆí•´ ì¡ŒìŠµë‹ˆë‹¤.
  * ì´ë¯¸ ë‚´ì¥ë˜ì–´ ìˆëŠ” íˆ´ì´ ìˆëŠ”ë°, ì™œ [libcluster](https://github.com/bitwalker/libcluster), [swarm](https://github.com/bitwalker/swarm), [horde](https://github.com/derekkraan/horde) ë¥¼ ë§Œë“œëŠ”ì§€ ê¶ê¸ˆí•´ ì¡ŒìŠµë‹ˆë‹¤.
* ê³¼ì—° ì´ê²ƒë§Œìœ¼ë¡œ `Fallacies of Distributed Computing` ì˜ ë¬¸ì œë“¤ì„ í•´ê²°í•  ìˆ˜ ìˆì„ì§€ ğŸ¤”

---

# ë
